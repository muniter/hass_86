#!/usr/bin/python3
# The script connects to the mqtt broker and suscribe to topics that start
# With it's message ID

import os
import json
import time
import threading
import dbus
import subprocess
# import logging
from gi.repository import GLib
from dbus.mainloop.glib import DBusGMainLoop

from subprocess import check_output as check_output

import paho.mqtt.client as mqtt


def get_data():
    '''Poll the status from system and return it as a json'''

    p = {}
    with open('/proc/uptime', 'r') as up, open('/proc/loadavg') as laverage:
        uptime = up.read().split()[0]
        laverage = laverage.read().strip().split()[:3]

    p['state'] = 'On'
    p['uptime'] = uptime
    p['users'] = check_output(['who', '-q'], encoding='utf-8')
    p['users'] = p['users'].strip().split('=')[-1]
    p['l1'], p['l5'], p['l15'] = laverage

    try:
        p['lock'] = 1 if check_output(['pgrep', '-c', 'swaylock']) else 0
    except subprocess.CalledProcessError:
        p['lock'] = 0

    payload = json.dumps(p)
    print(payload)
    return payload


def pub_status(client):
    '''Poll the status from system and publish it'''
    payload = get_data()
    client.publish(topic=_TOPIC_TELE_, payload=payload, retain=True)
    return True


def on_connect(client, userdata, flags, rc):
    '''Callback function to execute on connect/reconnect'''

    print(f'Connected with result code {str(rc)}')
    client.subscribe(_TOPIC_CMND_)
    pub_status(client)


def on_message(client, userdata, msg):
    '''Callback function to execute on message and send a json payload'''

    payload = msg.payload.decode('utf-8')
    print('recieved:', msg.topic, payload, sep=' ')
    command(client, payload)


def state_thread(interval=60):
    '''Thread function to preiodically send payload'''
    while True:
        pub_status(client)
        time.sleep(interval)


def command(client, payload):
    """Run a command defined in the configuration

    :client: The mqtt client object
    :payload: The message payload received
    :returns: True if a command was executed succesfully otherwise None
    """
    if payload == 'status':
        pub_status(client)
        return True
    # Other commands
    command = COMMANDS.get(payload, False)
    if command:
        print(f'Executing {payload}')
        # Since the command is a string and subprocess.run expects a
        # list the list is generated by splitting the string.
        subprocess.run(command.split(' '))
        return True

    print(f'Command {payload} not found')


def handle_sleep_and_shutdown(dbus_object, message=None):
    '''
    Callback for when system goes to sleeps and wakes up, or when it shutdowns
    and turns on.

    sender_keyword: I believe is a boolean represented as a subtype of int
    message: The dbus message
    '''
    if message.get_member() == 'PrepareForSleep':
        signal_name = 'sleep'
    elif message.get_member() == 'PrepareForSleep':
        signal_name = 'shutdown'

    if dbus_object.numerator == 1:
        print(f'Recieved system {signal_name} signal, setting off state')
        payload = {"state": "Off"}
        print(payload)
        payload = json.dumps(payload)
        client.publish(topic=_TOPIC_TELE_, payload=payload, retain=True)
    else:
        print(f'System waking up from {signal_name}, setting Online state')
        pub_status(client)

    return True


def setup_mqtt():
    """Setup the mqtt client and callbacks
    :returns: mqtt client object.
    """
    client = mqtt.Client()
    client.username_pw_set(
        os.environ.get('MQTT_USERNAME'),
        os.environ.get('MQTT_PASSWORD')
    )
    # Set will message in case of quick disconnect
    client.will_set(
        topic=_TOPIC_TELE_,
        payload='{"state": "Off"}',
        qos=1,
        retain=True
    )
    # Set the callbacks
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(host=_MQTT_BROKER_)
    # This loop is run in a thread.
    client.loop_start()
    return client


if __name__ == '__main__':
    # Global variables
    _NAME_ = os.environ.get('NAME')
    _TOPIC_TELE_ = f"{_NAME_}/tele"
    _TOPIC_CMND_ = f"{_NAME_}/cmnd"
    _MQTT_BROKER_ = os.environ.get('MQTT_BROKER')

    # The key is the payload that must be recieved, to execute the value
    # which is the command to execute
    COMMANDS = os.environ.get('COMMANDS').split(',')
    COMMANDS = dict(map(lambda x: x.split(':', 1), COMMANDS))

    # Setup the mqtt client
    client = setup_mqtt()

    # Thread that sends a messge every 60 seconds with the status
    state_thread = threading.Thread(target=state_thread, args=(60,))
    state_thread.start()

    DBusGMainLoop(set_as_default=True)
    bus = dbus.SystemBus()
    bus.add_signal_receiver(
        handler_function=handle_sleep_and_shutdown,
        signal_name='PrepareForSleep',
        dbus_interface='org.freedesktop.login1.Manager',
        bus_name='org.freedesktop.login1',
        message_keyword='message'
    )
    bus.add_signal_receiver(
        handler_function=handle_sleep_and_shutdown,
        signal_name='PrepareForShutdown',
        dbus_interface='org.freedesktop.login1.Manager',
        bus_name='org.freedesktop.login1',
        message_keyword='message'
    )
    # This loop runs in the main thread blocking
    loop = GLib.MainLoop()
    loop.run()
